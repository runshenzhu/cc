package com.obgun.frontend;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;

/**
 * Created by jessesleep on 11/11/15.
 */
public class Q4MemStore {
    private static final long MILESTONE = 100000;

    private static Map<String, ArrayList<HashtagInternal>> q4CacheMap = new TreeMap<>();

    private static class HashtagInternal {
        public int skewedTimestamp;
        public int count;
        public ArrayList<Long> userlist = new ArrayList<Long>();
        public String sourceText;

        public HashtagInternal( HashtagStructure hashtagStructure){
            this.skewedTimestamp = hashtagStructure.skewedTimestamp;
            this.count = hashtagStructure.count;
            for( Long user : hashtagStructure.userList ){
                userlist.add(user);
            }
            this.sourceText = hashtagStructure.sourceText;
        }
    }

    private static void addMap( List<HashtagStructure> hashtags ){
        if( !q4CacheMap.containsKey(hashtags.get(0).hashtag) ){
            q4CacheMap.put(hashtags.get(0).hashtag, new ArrayList<HashtagInternal>());
        }

        for( HashtagStructure hashtag : hashtags ){
            hashtag.userList.trimToSize();
            q4CacheMap.get(hashtag.hashtag).add(new HashtagInternal(hashtag));
        }
        q4CacheMap.get(hashtags).trimToSize();
    }

    /**
     * Read the Q4 data from the json file generated by MapRed
     * Return true if init success, else return false
     * @param jsonFilePath
     * @return
     */
    public static boolean initCache( String jsonFilePath ){
        try {
            BufferedReader br = new BufferedReader( new FileReader(jsonFilePath));
            // Read in Q4
            String line;
            long lineCount = 0;
            HashtagStructure hashtagStructure = null;

            if( (line = br.readLine()) != null ){
                hashtagStructure = new HashtagStructure(line);
            }

            while( line != null ){
                ArrayList<HashtagStructure> hashtagList = new ArrayList<HashtagStructure>();

                do{
                    lineCount += 1;
                    hashtagList.add(hashtagStructure);

                    if( ( line = br.readLine()) == null ){
                        break;
                    }

                    hashtagStructure = new HashtagStructure(line);
                } while ( hashtagStructure.hashtag.equals(hashtagList.get(0).hashtag));

                // sort the hash tags by the Q4 order rule
                Collections.sort(hashtagList);
                addMap(hashtagList);
            }

            if( lineCount % MILESTONE == 0 ){
                System.out.println("Load "+lineCount+" lines");
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
            return false;
        } catch ( IOException e ){
            e.printStackTrace();
            return false;
        }

        return true;
    }

    /**
     * Return empty string if not found
     * @param hashtag
     * @param nStr
     * @return
     */
    public final static String getQ4Response( String hashtag, String nStr ){
        StringBuilder response = new StringBuilder();
        List<HashtagInternal> hashtags = q4CacheMap.get(hashtag);
        if( hashtags == null ){
            return "";
        }
        int count = Integer.valueOf(nStr);

        for( int i = 0; i < count && i < hashtags.size(); ++i ){
            HashtagInternal hashInternal = hashtags.get(i);
            response.append(HbaseHandler.skewedTime2Date(hashInternal.skewedTimestamp)).append(":");
            response.append(String.valueOf(hashInternal.count)).append(":");
            int userCount = hashInternal.userlist.size();
            response.append(String.valueOf(hashInternal.userlist.get(0)));
            for( int u = 0; u < userCount; ++u ){
                response.append(",").append(String.valueOf(hashInternal.userlist.get(u)));
            }
            response.append(":").append(hashInternal.sourceText).append("\n");
        }
        return response.toString();
    }
}
